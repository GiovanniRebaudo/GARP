K_pos                = length(n_edge_minus_i)
n_edge_all[1:K_pos]  = n_edge_minus_i
} else {
K_pos               = length(n_edge_minus_i)
n_edge_all[1:K_pos] = n_edge_minus_i
}
}
n_edge_minus_i                         = n_edge_all
cl_memb_stable_i_old = cl_memb_all[i_stable]
n_stable_i = n_stable_minus_i[cl_memb_stable_i_old]
n_stable_minus_i[cl_memb_stable_i_old] = n_stable_i - 1
# if we are emptying a stable phase
if (n_stable_i==1){
cl_memb_edge_mat = cl_memb_all_mat[obs_edge,]
# if the stable phase has an edge associated cannot be emptied
if(any(cl_memb_edge_mat==cl_memb_stable_i_old)){
if(acc_p){
Acceptance_out[r, N_T+i] = 0
}
break_ind = T
} else {
# print(K_S-1)
# We have emptied a stable phase
K_S     = K_S-1
K_T_max = K_S*(K_S-1)/2
ind_empty = T
}
}
if(!break_ind){
if(acc_p){
Acceptance_out[r, N_T+i] = 1
}
# we use dmNorm. It can be faster to write our function to avoid
# repeating matrix operation on Sigma_mat every time
if(ind_empty){
# It can be made more efficient
b_minus_i_stable   = double(K_S_plus+1)
n_i_pos_stable     = which(n_stable_minus_i>0)
b_minus_i_edge     = double(K_T_max_plus)
n_i_pos_edge       = which((Map_k_edge[,1] %in% n_i_pos_stable)&
(Map_k_edge[,2]%in%n_i_pos_stable))
b_minus_i_stable[c(n_i_pos_stable,K_S_plus+1)] = p_s*urn_GN_norm(
freq_minus=n_stable_minus_i[n_i_pos_stable], gamma_GN, K_S) *
c(mniw::dmNorm(y_i, mu=Mu_stable[n_i_pos_stable,],
Sigma=Sigma_stable[,,n_i_pos_stable]),
dmvt_new[i_stable])
b_minus_i_edge[n_i_pos_edge] = (1-p_s)*urn_Dir_all_norm_div(
n_edge_minus_i[n_i_pos_edge],alpha_Dir,KM=K_S)*
mniw::dmNorm(y_i, mu=Mu_edge[n_i_pos_edge,],
Sigma=Sigma_edge[,,n_i_pos_edge])
} else {
b_minus_i_stable = p_s*urn_GN_norm(freq_minus=n_stable_minus_i,
gamma_GN, K_S) *
c(mniw::dmNorm(y_i, mu=Mu_stable, Sigma=Sigma_stable),
dmvt_new[i_stable])
b_minus_i_edge = (1-p_s)*urn_Dir_all_norm_div(n_edge_minus_i,alpha_Dir,
KM=K_S)*
mniw::dmNorm(y_i, mu=Mu_edge, Sigma=Sigma_edge)
}
b_minus_i_all     = c(b_minus_i_stable,b_minus_i_edge)
cl_memb_i         = sample.int(n=K_T_max_plus+K_S_plus+1, size=1,
prob=b_minus_i_all, useHash = F)
stable_i          = ifelse(cl_memb_i<(K_S_plus+2),1,0)
# If the cell i was previously in a stable phase (and remains stable)
if (stable_i == 1){
# If cell i changes (stable) cluster
if(cl_memb_stable_i_old!=cl_memb_i){
cl_memb_all[i_stable]  = cl_memb_i
cl_memb_all_mat[i_stable,] = c(cl_memb_i,cl_memb_i)
# If we open a new stable cluster
if (cl_memb_i == (K_S_plus+1)){
# print(K_S+1)
# Sample new stable parameter
Lambda_Sig_new         = solve(Lambda0 + kappa0/kappa_new * (y_i-mu0)%*%t(y_i-mu0))
Mean_mu_new            = (kappa0*mu0+y_i)/kappa_new
Sigma_stable_new       = bayesm::rwishart(nu=nu_new , V=Lambda_Sig_new)$IW
Mu_stable_new          = mvtnorm::rmvnorm(n=1, mean=Mean_mu_new, sigma=Sigma_stable_new/kappa_new)
Mu_stable              = rbind(Mu_stable, Mu_stable_new)
Sigma_stable           = array(c(Sigma_stable, Sigma_stable_new), dim = c(2, 2, K_S_plus+1))
# Compute new edge parameters associated
# (we are computing also useless ones:
# it can be made slightly faster)
kt              = K_T_max_plus
Mu_edge_temp    = Mu_edge
Map_k_edge_temp = Map_k_edge
Sigma_edge_temp = Sigma_edge
Map_k_edge      = matrix(nrow=K_T_max_plus+K_S_plus, ncol=P)
Mu_edge         = matrix(nrow=K_T_max_plus+K_S_plus, ncol=P)
Sigma_edge      = array(0,dim=c(P,P,K_T_max_plus+K_S_plus))
Mu_edge[1:K_T_max_plus,]     = Mu_edge_temp
Map_k_edge[1:K_T_max_plus,]  = Map_k_edge_temp
Sigma_edge[,,1:K_T_max_plus] = Sigma_edge_temp
for (k_s in 1:K_S_plus){
kt                 = kt+1
Map_k_edge[kt,]    = c(cl_memb_i,k_s)
unr                = rbind(Mu_stable[k_s,],Mu_stable_new)
par_out            = Edge_Parameters(unrot_means=unr)
Mu_edge[kt,]       = par_out$mean_edge
Sigma_edge[,,kt]   = par_out$var_edge
}
# Save new parameter values
K_S                    = K_S+1
K_S_plus               = K_S_plus+1
K_T_max                = K_S*(K_S-1)/2
K_T_max_plus           = K_S_plus*(K_S_plus-1)/2
}
}
# if cell i moves from a stable to a transition phase
} else if (stable_i == 0){
stable[i_stable]           = stable_i
cl_memb_i_edge             = cl_memb_i - (K_S_plus+1)
cl_memb_all[i_stable]      = -cl_memb_i_edge
cl_memb_all_mat[i_stable,] = Map_k_edge[cl_memb_i_edge,]
}
}
}
# Reordering in each iteration
obs_stable                 = which(stable==1)
cl_memb_stable             = cl_memb_all[obs_stable]
cl_memb_stable_uni         = unique(cl_memb_stable)
cl_memb_stable             = plyr::mapvalues(cl_memb_stable,
from=cl_memb_stable_uni,
to=1:K_S)
cl_memb_all_mat            = plyr::mapvalues(cl_memb_all_mat,
from=cl_memb_stable_uni,
to=1:K_S)
# Remap edge and stable phases
obs_edge                      = which(stable==0)
cl_memb_edge                  = cl_memb_all[obs_edge]
cl_memb_edge_uni              = unique(cl_memb_edge)
cl_memb_edge_mat              = cl_memb_all_mat[obs_edge,]
cl_memb_edge_mat_uni          = unique(cl_memb_edge_mat)
cl_memb_all[obs_stable]       = cl_memb_stable
# Sample unique kernel parameters Bivariate Gaussian
# Reorder parameters
Sigma_stable   = Sigma_stable[,,cl_memb_stable_uni]
Mu_stable      = Mu_stable[cl_memb_stable_uni,]
# Compute associated edge parameters
K_T_max     = K_S*(K_S-1)/2
Map_k_edge  = matrix(nrow=K_T_max,ncol=2)
Sigma_edge  = array(0,dim=c(P,P,K_T_max))
Mu_edge     = matrix(0,nrow=K_T_max, ncol=P)
kt = 1
for (k_s1 in 2:K_S){
for (k_s2 in 1:(k_s1-1)){
Map_k_edge[kt,]  = c(k_s1,k_s2)
unr              = Mu_stable[c(k_s1,k_s2),]
par_out          = Edge_Parameters(unrot_means=unr)
Mu_edge[kt,]     = par_out$mean_edge
Sigma_edge[,,kt] = par_out$var_edge
kt               = kt+1
}
}
# Finish to remap
K_T                           = nrow(cl_memb_edge_mat_uni)
if (K_T>0){
cl_memb_edge_mat_uni        = unique(t(apply(cl_memb_edge_mat_uni, 1,
function(x){sort(x,
decreasing=T)})))
K_T                         = nrow(cl_memb_edge_mat_uni)
cl_memb_edge_uni_new        = double(K_T)
for(k_t in 1:K_T){
cl_memb_edge_uni_new[k_t] = which(apply(Map_k_edge, 1, function(x) {
all(x==cl_memb_edge_mat_uni[k_t,])}))
}
cl_memb_edge                = plyr::mapvalues(cl_memb_edge,
from=cl_memb_edge_uni,
to=cl_memb_edge_uni_new)
}
cl_memb_all[obs_edge]   = -cl_memb_edge
# MH step
for (ks in 1:K_S){
i_ks             = which(cl_memb_all==ks)
n_ks             = length(i_ks)
y_iks            = y[i_ks,]
if(n_ks==1) {
mean.y_ks      = y_iks
S_ks           = 0
kappa_ks       = kappa_new
nu_ks          = nu_new
} else {
mean.y_ks      = colMeans(y_iks)
S_ks           = var(y_iks)*(n_ks-1)
kappa_ks       = kappa0+n_ks
nu_ks          = n_ks+nu0
}
Lambda_Sig_ks    = solve(Lambda0 + S_ks + kappa0*n_ks/kappa_ks*
(mean.y_ks-mu0)%*%t((mean.y_ks-mu0)))
mu_muks          = (n_ks*mean.y_ks + kappa0*mu0)/kappa_ks
Sigma_ks_prop    = bayesm::rwishart(nu=nu_ks, V=Lambda_Sig_ks)$IW
Mu_ks_prop       = mvrnorm(n=1, mu=mu_muks, Sigma=Sigma_ks/kappa_ks)
Mu_edge_prop     = Mu_edge
Sigma_edge_prop  = Sigma_edge
# Compute acceptance probability
edge_ks          = which(((Map_k_edge[,1]==ks)+(Map_k_edge[,2]==ks))==1)
edge_ks          = edge_ks[edge_ks %in% cl_memb_edge]
if (length(edge_ks)>0){
log_rho_acc      = 0
for (kedge in edge_ks){
i_kedge        = which(cl_memb_all==-kedge)
n_kedge        = length(i_kedge)
y_i_kedge      = y[i_kedge,]
if(n_kedge==1) {
mean_y_kedge = y_i_kedge
} else {
mean_y_kedge = colMeans(y_i_kedge)
}
# Compute proposed new edge parameters
k_s_k_s2                 = Map_k_edge[kedge,]
k_s2                     = k_s_k_s2[k_s_k_s2!=ks]
unr                      = Mu_stable[k_s_k_s2,]
par_out                  = Edge_Parameters(unrot_means=unr)
Mu_kedge_prop            = par_out$mean_edge
Sigma_kedge_prop         = par_out$var_edge
Mu_edge_prop[kedge,]     = Mu_kedge_prop
Sigma_edge_prop[,,kedge] = Sigma_kedge_prop
Mu_edge_old              = Mu_edge[kedge,]
Sigma_edge_old           = Sigma_edge[,,kedge]
log_rho_acc              = log_rho_acc + n_kedge/2*(
t((mean_y_kedge-Mu_edge_old)%*%solve(Sigma_edge_old)%*%
(mean_y_kedge-Mu_edge_old)) - t((mean_y_kedge-Mu_kedge_prop)%*%
solve(Sigma_kedge_prop)%*%
(mean_y_kedge-Mu_kedge_prop))+log(det(Sigma_edge_old))-
log(det(Sigma_kedge_prop)) )
}
move                 = (log(runif(1)) < log_rho_acc)
if(move){
Sigma_stable[,,ks] = Sigma_ks_prop
Mu_stable[ks,]     = Mu_ks_prop
Mu_edge            = Mu_edge_prop
Sigma_edge         = Sigma_edge_prop
}
} else {
Sigma_stable[,,ks]   = Sigma_ks_prop
Mu_stable[ks,]       = Mu_ks_prop
}
}
# Compute stable frequency
N_S = length(cl_memb_stable)
N_T = N-N_S
# Save output
# If you want n_clust
n_clus_out[r,]                  = c(K_S,K_T)
Mu_stable_out[1:K_S,,r]         = Mu_stable
if(K_T>0){
index_edge_out                = unique(cl_memb_edge)
if(max(index_edge_out)<N){
Mu_edge_out[index_edge_out,,r]     = Mu_edge[index_edge_out,]
Sigma_edge_out[,,index_edge_out,r] = Sigma_edge[,,index_edge_out]
}
}
Sigma_stable_out[,,1:K_S,r]     = Sigma_stable
cl_memb_stable_out[r,stable==1] = cl_memb_stable
cl_memb_all_out[r,]             = cl_memb_all
stable_out[r,]                  = stable
if(r%%verbose_step == 0){
# print iteration
print(r)
if(Plot==T){
col_clus = cl_memb_all
K_ma = max(K_S,K_T)
if(K_T==0){
col_clus = viridis(K_ma)[col_clus]
} else if(K_T==1){
col_clus = ifelse(col_clus<0,1,viridis(K_ma)[abs(col_clus)])
} else if (K_T>1){
col_clus = ifelse(col_clus<0,1, viridis(K_ma)[abs(col_clus)])
}
plot(y, col=col_clus, pch=16)
}
}
}
# Output
if(!acc_p){
Acceptance_out=NA
}
return(list(n_clus_out         = n_clus_out,
Mu_stable_out     = Mu_stable_out,
Sigma_stable_out   = Sigma_stable_out,
Mu_edge_out        = Mu_edge_out,
Sigma_edge_out     = Sigma_edge_out,
cl_memb_stable_out = cl_memb_stable_out,
cl_memb_all_out    = cl_memb_all_out,
stable_out         = stable_out,
Acceptance_out     = Acceptance_out
))
}
# Set the seed for reproducibility
set.seed(123)
output_sim_1_ind = GARP_MCMC(data    = data,
mu0     = mu0,
kappa0  = kappa0,
nu0     = nu0,
Lambda0 = Lambda0,
p_s     = 1,
Niter   = Niter,
Plot    = TRUE,
acc_p   = FALSE)
# it can be avoided by renaming
y            = data
N            = nrow(y)
y
data
data
output_sim_1_ind = GARP_MCMC(data    = y,
mu0     = mu0,
kappa0  = kappa0,
nu0     = nu0,
Lambda0 = Lambda0,
p_s     = 1,
Niter   = Niter,
Plot    = TRUE,
acc_p   = FALSE)
# Load relevant libraries, functions and data ----------------------------------
rm(list=ls())
# Set the working directory to the current folder
# Code to set the working directory to the current folder from RStudio
library(rstudioapi)    # version 0.14
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(MASS)          # version 7.3-58.2
library(ggplot2)       # version 3.4.2
theme_set(theme_bw(base_size = 14))
library(viridis)       # version 0.6.2
library(salso)         # version 0.3.29
library(reshape2)      # version 1.4.4
library(Cairo)         # version 1.6-0
library(scales)        # version 1.2.1
library(plyr)          # version 1.8.8
library(mvtnorm)       # version 1.1-3
library(LaplacesDemon) # version 16.1.6
library(bayesm)        # version 3.1-5
library(mniw)          # version 1.0.1
library(xtable)        # version 1.8-4
library(dplyr)         # version 1.1.1
# Load functions
source("GARP_fcts.R")
set.seed(123)
## Sim 1
P = 2
ver_1_mean = c(7,0)
ver_2_mean = c(-3,6)
ver_3_mean = c(3,5)
ver_4_mean = c(-4,-5)
ver_5_mean = c(2,-4)
ver_1_var = diag(rep(1,2))/4
ver_2_var = diag(rep(1,2))/4
ver_3_var = diag(rep(1,2))/4
ver_4_var = diag(rep(1,2))/4
ver_5_var = diag(rep(1,2))/4
n_s = 200
n_e = 100
data_sim_ver_1 = mvrnorm(n_s, ver_1_mean, ver_1_var)
data_sim_ver_2 = mvrnorm(n_s, ver_2_mean, ver_2_var)
data_sim_ver_3 = mvrnorm(n_s, ver_3_mean, ver_3_var)
data_sim_ver_4 = mvrnorm(n_s, ver_4_mean, ver_4_var)
data_sim_ver_5 = mvrnorm(n_s, ver_5_mean, ver_5_var)
True_par          = Edge_Parameters(unrot_means =
rbind(ver_5_mean,ver_4_mean))
data_sim_edg_1 = mvrnorm(n_e, True_par$mean_edge, True_par$var_edge)
True_par          = Edge_Parameters(unrot_means =
rbind(ver_3_mean,ver_2_mean))
data_sim_edg_2 = mvrnorm(n_e, True_par$mean_edge, True_par$var_edge)
True_par          = Edge_Parameters(unrot_means =
rbind(ver_1_mean,ver_5_mean))
data_sim_edg_3 = mvrnorm(n_e, True_par$mean_edge, True_par$var_edge)
True_par          = Edge_Parameters(unrot_means =
rbind(ver_1_mean,ver_3_mean))
data_sim_edg_4 = mvrnorm(n_e, True_par$mean_edge, True_par$var_edge)
True_par          = Edge_Parameters(unrot_means =
rbind(ver_5_mean,ver_3_mean))
data_sim_edg_5 = mvrnorm(n_e, True_par$mean_edge, True_par$var_edge)
data_sim = rbind(data_sim_ver_1, data_sim_ver_2, data_sim_ver_3,
data_sim_ver_4, data_sim_ver_5, data_sim_edg_1,
data_sim_edg_2, data_sim_edg_3, data_sim_edg_4,
data_sim_edg_5)
data_sim = data_sim[,c(2,1)]
xlim_sim_data = c(min(data_sim[,1]),max(data_sim[,1]))
ylim_sim_data = c(min(data_sim[,2]),max(data_sim[,2]))
xylim_sim     = c(min(xlim_sim_data,ylim_sim_data),
max(xlim_sim_data,ylim_sim_data))
Cluster = factor(c(rep("1",n_s), rep("5",n_s), rep("3",n_s), rep("4",n_s),
rep("2",n_s), rep("2,4",n_e), rep("3,5",n_e), rep("1,2",n_e),
rep("1,3",n_e), rep("2,3",n_e)))
data_plot = cbind.data.frame(data.frame(data_sim),Cluster)
colnames(data_plot)=c("X","Y","Cluster")
data_plot_vertex = data_plot %>% filter(Cluster %in% 1:5)%>%
droplevels()
data_plot_edge   = data_plot %>% filter(!(Cluster %in% 1:5))%>%
droplevels()
colnames(data_plot_vertex) = c("X","Y","Cluster")
data_plot_vertex$Cluster         = factor(data_plot_vertex$Cluster)
levels(data_plot_vertex$Cluster) = c(paste0("V",1:5))
Segment_data           = matrix(nrow=5,ncol=4)
colnames(Segment_data) = c("x","y","xend","yend")
Segment_data[1,] = c(ver_1_mean,ver_3_mean)
Seg1 = data.frame(t(Segment_data[1,]))
Segment_data[2,] = c(ver_2_mean,ver_3_mean)
Seg2 = data.frame(t(Segment_data[2,]))
Segment_data[3,] = c(ver_5_mean,ver_4_mean)
Seg3 = data.frame(t(Segment_data[3,]))
Segment_data[4,] = c(ver_5_mean,ver_1_mean)
Seg4 = data.frame(t(Segment_data[4,]))
Segment_data[5,] = c(ver_3_mean,ver_5_mean)
Seg5 = data.frame(t(Segment_data[5,]))
Plot_S2 = ggplot() +geom_point(data=data_plot_vertex, aes(x=X,y=Y))+
geom_point(data=data_plot_edge,aes(x=X,y=Y))+
xlab("Dim 1")+ylab("Dim 2")+labs(color="Vertex")+
geom_segment(data=Seg1, mapping =aes(x = y, y = x, xend = yend, yend = xend),
col="red",alpha=3,size=1)+
geom_segment(data=Seg2, mapping =aes(x = y, y = x, xend = yend, yend = xend),
col="red",alpha=3,size=1)+
geom_segment(data=Seg3, mapping =aes(x = y, y = x, xend = yend, yend = xend),
col="red",alpha=3,size=1)+
geom_segment(data=Seg4, mapping =aes(x = y, y = x, xend = yend, yend = xend),
col="red",alpha=3,size=1)+
geom_segment(data=Seg5, mapping =aes(x = y, y = x, xend = yend, yend = xend),
col="red",alpha=3,size=1)+
theme_bw()+theme(legend.position = "right", text = element_text(size=20))
# If you want to save the plot
Save_Plot = TRUE
if(Save_Plot){CairoPNG(filename = './Image/Data_sim.png', width = 500,
height = 400)}
Plot_S2
if(Save_Plot){invisible(dev.off())}
y = data_sim
P = ncol(y)
N = nrow(y)
# If you want to save the plot
Save_Plot = TRUE
# Sim 1 scatter plot
# (Figure S.2 in the supplementary materials)
Plot_S1 = edge_countorplot(vertices  = rbind(c(-2,-2), c(3,3)),
data.grid = expand.grid(X=seq(-3,4,length.out=800),
Y=seq(-3,4,length.out=800)))
if(Save_Plot){
CairoPNG(filename = './Image/Gauss_Edge_Countor.png', width=500, height=400)}
Plot_S1
if(Save_Plot){invisible(dev.off())}
# If you want to save the plot
Save_Plot = F
source("C:/Users/39339/Dropbox/GitHub/GARP/GARP_extra.R", echo=TRUE)
# Codes accompanying "Graph-Aligned Random Partition Model (GARP)"
# Load relevant libraries, functions and data ----------------------------------
rm(list=ls())
# Set the working directory to the current folder
# Code to set the working directory to the current folder from RStudio
library(rstudioapi) # version 0.14
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(MASS)          # version 7.3-58.2
library(ggplot2)       # version 3.4.2
theme_set(theme_bw(base_size = 14))
library(viridis)       # version 0.6.2
library(salso)         # version 0.3.29
library(reshape2)      # version 1.4.4
library(Cairo)         # version 1.6-0
library(scales)        # version 1.2.1
library(plyr)          # version 1.8.8
library(mvtnorm)       # version 1.1-3
library(LaplacesDemon) # version 16.1.6
library(bayesm)        # version 3.1-5
library(mniw)          # version 1.0.1
library(xtable)        # version 1.8-4
# Load functions
source("GARP_fcts.R")
# Load data
y = get(load("./Data-and-Results/Data.RData"))
P = ncol(y)
N = nrow(y)
# If you want to save the plot
Save_Plot = TRUE
# Data scatter plot (Figure 1 in the main manuscript)
Plot_1 = pre_plot(y)
if(Save_Plot){
CairoPNG(filename = './Image/Mice_Data.png', width = 500, height = 400)}
Plot_1
if(Save_Plot){invisible(dev.off())}
# Gaussian edge contour plot
# (Figure S.1 in the supplementary materials)
Plot_S1 = edge_countorplot(vertices  = rbind(c(-2,-2), c(3,3)),
data.grid = expand.grid(X=seq(-3,4,length.out=800),
Y=seq(-3,4,length.out=800)))
if(Save_Plot){
CairoPNG(filename = './Image/Gauss_Edge_Countor.png', width=500, height=400)}
Plot_S1
if(Save_Plot){invisible(dev.off())}
# Run the MCMC -----------------------------------------------------------------
# GARP hyperparameters
# Random partition parameters
p_s       = 0.5 # change to p_v
gamma_GN  = 0.5
alpha_Dir = 0.5
## NIG hyperparameters
mu0       = colMeans(y)
kappa0    = 0.001
nu0       = 100
Lambda0   = diag(rep(15,P))
# MCMC quantities
Niter     = 10000
run_MCMC  = FALSE
Lambda0   = diag(rep(150,P))
# Set the seed for reproducibility
set.seed(123)
# pt1 = proc.time() # compute time
output = GARP_MCMC(data    = data,
mu0     = mu0,
kappa0  = kappa0,
nu0     = nu0,
Lambda0 = Lambda0,
p_s     = p_s,
Niter   = Niter,
Plot    = FALSE,
acc_p   = FALSE)
